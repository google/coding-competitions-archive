
<html>
  <head>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <script src="https://www.gstatic.com/external_hosted/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML,Safe"></script>
    <script>
      MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
          inlineMath: [ ['$$$','$$$'] ],
          displayMath: [ ['$$$$','$$$$'] ],
          skipTags: ["script","noscript","style","textarea","pre"],  // allow <code>.
          processEscapes: true
        },
        showProcessingMessages: false,
        messageStyle: "none",
        "HTML-CSS": { scale: 90, fonts: ["TeX"] }
      });
      MathJax.Ajax.loadComplete('https://codingcompetitions.withgoogle.com/static/mathjax-config.js');
      </script>
    <style>
.problem-io-wrapper-new .sampleio-wrapper {
  display: flex;
  flex-direction: row;
  align-items: stretch;
  justify-content: flex-start;
  margin-top: 1rem;
  padding-left: 12.5px;
  padding-right: 12.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-input {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: -12.5px;
  margin-right: 12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-output {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: 12.5px;
  margin-right: -12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-text {
  flex: 1;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-download-button {
  display: none;
  cursor: pointer;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button {
  display: none;
  cursor: pointer;
  position: relative;
  margin-left: 5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup {
  visibility: hidden;
  width: 100px;
  background-color: #999;
  color: #fff;
  text-align: center;
  border-radius: 3px;
  padding: 4px 0;
  position: absolute;
  z-index: 1;
  top: 125%;
  left: 50%;
  margin-left: -50px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup::before {
  content: "";
  position: absolute;
  bottom: 100%;
  left: 50%;
  margin-left: -5px;
  border-width: 5px;
  border-style: solid;
  border-color: transparent transparent #999 transparent;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup-shown {
  visibility: visible;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button-hidden {
  display: none;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content {
  display: flex;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 0px 9.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content .sample-content-text {
  flex-grow: 1;
  margin: 0px;
  overflow-x: auto;
  padding-bottom: 9.5px;
  line-height: normal;
  white-space: pre-wrap;
}
.test-data-download-wrapper {
  display: none;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  width: fit-content;
  max-width: 600px;
  margin-top: 1rem;
}
.test-data-download-wrapper .test-data-download-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-text {
  flex: 1;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-download-button {
  display: none;
  cursor: pointer;
}
.test-data-download-wrapper .test-data-download-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper {
  display: flex;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  max-width: 600px;
  margin-top: 1rem;
}
.sample-interaction-wrapper .sample-interaction-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.sample-interaction-wrapper .sample-interaction-header .sample-interaction-text {
  flex: 1;
}
.sample-interaction-wrapper .sample-interaction-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #e6e6e6;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-judge-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: left;
  flex-grow: 1;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-solution-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: right;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box .sample-interaction-judge-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper {
  display: flex;
  flex-direction: row-reverse;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box .sample-interaction-solution-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-note {
  font-style: italic;
  color: #4e4e4e;
  margin-right: 20%;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-note {
  font-style: italic;
  color: #4e4e4e;
  margin-left: 20%;
  text-align: end;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-section-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: center;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-spacer {
  height: 9.5px;
}
    </style>
  </head>
  <body>
    <div>
<h3>Code Jam 2017 - Round 2</h3><h1>Analysis: Roller Coaster Scheduling</h1><h2>Roller Coaster Scheduling: Analysis</h2>
<h3>Small dataset</h3>
<p>
  There are various ways to solve the Small dataset; for instance, it can be
  reduced to a
  <a href="https://en.wikipedia.org/wiki/Max-flow_min-cut_theorem">flow problem</a>.
  It is also possible to find a greedy strategy or even a formula: the number
  of rides needed is max(number of tickets for customer 1, number of tickets
  for customer 2, number of tickets with seat 1), and the number of promotions
  needed is max(0, (maximum among counts of i-th seat among all tickets) -
  number of rides needed). However, these strategies are tricky to prove. The
  rest of our analysis will shed some light on why they work.
</p>
<h3>Large dataset</h3>
<p>
  To solve the Large dataset, we can start with observations similar to those
  in the Small case: the number of tickets held by any one person is a lower
  bound on the number of total rides, and so is the number of tickets for position
  1. This is because the set of tickets held by any one person, and the set of tickets
  for position 1, share the property that no two tickets in the set can be honored
  in the same ride, even with promotions. An extension of this is that for the set of
  all tickets for positions 1, 2, ..., K, at most K of them can be honored by a single
  ride (possibly using promotions). This means that, if S<sub>K</sub> is the number of
  tickets for positions up to and including K, ceil(S<sub>K</sub> / K) is also a lower
  bound on the final number of rides.
</p><p>
  It is not difficult to see this when there is only one ticket per customer: if the
  maximum of all those lower bounds is R, for as long as there is some position P such
  that there are more than R tickets for position P, we can promote any ticket for position
  P to some previous position that has less than R tickets assigned, which is guaranteed
  to exist due to the R &ge; ceiling(S<sub>P</sub> / P).
  After that, no position is assigned more than R tickets. Since there are no repeated
  customers, we can just grab one ticket for each position that has tickets remaining and
  assign them to a ride until there are no more left. This will yield an assignment with
  exactly R rides, and we proved above that there can't be less than R.
</p><p>
  When there are customers holding more than one ticket, our greedy assignment in the last
  step above might fail. We can still prove that there is an assignment that works with a bit
  of mathematical modeling. Consider a fixed ride plan. Let us define the ride plan matrix as a
  square matrix of side S = max(<b>N</b>,<b>C</b>).
  The first <b>C</b> rows represent customers and the first <b>N</b> columns represent positions.
  The remaining rows or columns represent fake customers or positions, whose role will be clear
  in a moment. For each ride in the plan, we construct a one-to-one assignment of customers
  and positions. Customers that participate in the ride are assigned to their position on it.
  Customers that do not are assigned to
  empty positions or fake positions. If there are more positions than customers, each empty
  position is assigned a fake customer. Then, the value of a given cell of the ride plan matrix
  is the number of times the represented customer was assigned to the represented position.
  Notice that the value is an upper bound on the number of times a customer actually rode in the
  position, but not the exact number.
</p><p>
  Notice that for any ride plan consisting of R rides, its ride plan matrix will have
  rows and columns that sum up to R. This is because for each ride, there is exactly one cell
  per row and one cell per column that gets a 1 added to it.
  The most interesting realization is that we can go the other way: for any matrix M such that
  all its rows and columns add up to R, there is a ride plan consisting of R rides such that M
  is a ride plan matrix for it. The proof is a simple variation on the
  <a href="https://en.wikipedia.org/wiki/Doubly_stochastic_matrix#Birkhoff_polytope_and_Birkhoff.E2.80.93von_Neumann_theorem">Birkhoffâ€“von Neumann theorem</a>,
  which implies a matrix with that property can be expressed as a sum of
  <a href="https://en.wikipedia.org/wiki/Permutation_matrix">permutation matrices</a>,
  and each permutation matrix corresponds to a possible ride.
</p><p>
  A given set of tickets can also be represented by a matrix of side S by having a cell contain the
  number of tickets a given cusotmer holds for a given position. Let us say that a matrix M is
  less than or equal to another matrix M', if and only if the cell at row i and column j in M is
  less than or equal to that the value of the cell at row i and column j in M'. After promotions,
  we need the matrix representing the tickets to be less than or equal to the ride plan matrix.
</p><p>
  Notice now that the greedy promotion algorithm presented in the second paragraph of this
  section, actually yields a ticket matrix such that no row or column exceeds the established
  lower bound R, even if there is more than one ticket per customer. The proof is exactly the
  proof above. What was missing before was a way to know that set of tickets could be turned
  into an actual ride plan in the case where there is more than one ticket per customer.
  We now have such a way, which means the originally naive solution is actually a full solution
  for the problem. Moreover, since we need to report the minimum number of promotions and not
  the promotions themselves, we can just add S<sub>P</sub> - R for each position P such that
  S<sub>P</sub> &gt; R, and we are done.
</p>


  <div class="test-data-download-wrapper">
    <div class="test-data-download-header">
      <div class="test-data-download-header-text">Test Data</div>
      <div class="test-data-download-header-download-button">
        <a href="test_data.zip" target="_blank">
          <i class="material-icons grey">save_alt</i>
        </a>
      </div>
    </div>
    <div class="test-data-download-content">
      <div class="test-data-download-warning">
        <span class="material-icons" style="color: grey; vertical-align: middle;">info</span>
        <span style="vertical-align: middle;">We recommend that you practice debugging solutions without looking at the test data.</span>
      </div>
    </div>
  </div>



    </div>
  </body>
</html>
